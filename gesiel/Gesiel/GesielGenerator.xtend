/*
 * generated by Xtext 2.12.0
 */
package org.mito.gesiel.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */

import org.mito.gesiel.gesiel.Entity
import org.mito.gesiel.gesiel.Relation
import org.mito.gesiel.gesiel.ROneToOne
import org.mito.gesiel.gesiel.ROneToMany
import org.mito.gesiel.gesiel.RManyToMany




import java.util.*

import org.mito.gesiel.gesiel.impl.CharImpl
import org.mito.gesiel.gesiel.impl.VarcharImpl
import org.mito.gesiel.gesiel.impl.TextImpl
import org.mito.gesiel.gesiel.impl.BoolImpl
import org.mito.gesiel.gesiel.impl.IntegerImpl
import org.mito.gesiel.gesiel.impl.SerialImpl
import org.mito.gesiel.gesiel.impl.DateImpl
import org.mito.gesiel.gesiel.impl.TimeImpl
import org.mito.gesiel.gesiel.impl.TimestampImpl
import org.mito.gesiel.gesiel.impl.TimestampzImpl
import org.mito.gesiel.gesiel.impl.IntervalImpl
import org.mito.gesiel.gesiel.impl.NumericImpl
import org.mito.gesiel.gesiel.Attribute
import org.mito.gesiel.gesiel.Config
import org.eclipse.xtext.naming.IQualifiedNameProvider
 
import com.google.inject.Inject
import org.mito.gesiel.gesiel.FileNameConfig

class Table{
	public String name
	public List<Column> columns
	public String extend
	new(String name){
		this.name = name.toLowerCase()
		this.columns = new ArrayList()
	}
	
	def void add(Column col){
		this.columns.add(col)
	}
		
	override toString(){
		val extend = if (extend !== null) " INHERITS (" + extend.toLowerCase() + ")" else ""
		val pks = columns.filter[primary].map[name]
		val strPks = if (pks.length > 0) "CONSTRAINT " + name + "_pk" + " PRIMARY KEY " + "(" + pks.join(",") + ")" else ""
		return "CREATE TABLE " + this.name + " (\n\t" + this.columns.join(",\n\t") + ",\n\t" + strPks + "\n)"+extend+"; \n\n"
	}
}


class Column{
	public String name
	public String type
	public String deflt
	public boolean allowNull
	public boolean unique
	public boolean primary
	
	new(String name, String type){
		this.name = name.toLowerCase()
		this.type = type.toUpperCase()
		this.allowNull = false
		this.unique = false
		this.deflt = null
		this.primary = false
	}
	
	new(String name, String type, boolean allowNull, boolean unique, String deflt, boolean primary){
		this.name = name.toLowerCase()
		this.type = type.toUpperCase()
		this.allowNull = allowNull
		this.unique = unique
		this.deflt = deflt
		this.primary = primary
	}
	
	def toPython(){
		
	}
	
	override toString(){
		val deflt = if (this.deflt !== null) " DEFAULT " + this.deflt else ""
		val unique = if (unique) " UNIQUE" else ""
		val notNull = if (!allowNull) " NOT NULL" else ""
		
		return name + " " + type + notNull + unique + deflt
	}
	
}


class ForeignKey{
	public String table
	public String tableRef
	public String column
	public String columnRef
	public int num
	
	new (String table, String tableRef, String column, String columnRef){
		this.table = table.toLowerCase()
		this.tableRef = tableRef.toLowerCase()
		this.column= column.toLowerCase()
		this.columnRef = columnRef.toLowerCase()
		this.num = 0
	}
	
	override toString(){
		"ALTER TABLE " + table + " ADD CONSTRAINT " + table + "_fk" + num + " FOREIGN KEY (" + column + ") REFERENCES " + tableRef + "(" + columnRef + ");" 
	}
}



class GesielGenerator extends AbstractGenerator {
	
	Map<String, Table> tables = new LinkedHashMap<String, Table>()
	Map<String, ArrayList<ForeignKey>> fks = new HashMap<String, ArrayList<ForeignKey>>()
	String filename = "gesiel"
	String pythonType = ""
	Map<String, HashSet<String>> imports = new HashMap<String, HashSet<String>>()
	
	@Inject extension IQualifiedNameProvider
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (c : resource.allContents.toIterable.filter(Config)) {
			if (c instanceof FileNameConfig){
				val fnameConf = c as FileNameConfig
				this.filename = fnameConf.name.toString()
			}
		}
		
		
		for (e : resource.allContents.toIterable.filter(Entity)) {
	        fsa.generateFile(
	            "/models/"+e.name.toString().toLowerCase() + ".py",
	            e.compile)
	    }

		
		
		fsa.generateFile(this.filename + ".sql", resource.start)
		fsa.generateFile("db_create.sh", createSh)
		
		
	}
	
	def dispatch compile(Entity e) {
		imports.clear()
		val Attribute[] attOrdered = newArrayOfSize(e.attributes.size())
		var left = 0
		var right = attOrdered.length - 1
		for (at: e.attributes){
			if (at.modifier !== null && at.modifier.allowNull)
				attOrdered.set(right--, at)
			else
				attOrdered.set(left++, at)
			
			at.compile
		}
		
		
		val List<ROneToOne> relImports = new ArrayList<ROneToOne>()
		
		for( rel : e.relations){
			val res = rel.compile
			if (res == "OneToOne")
				relImports.add(rel as ROneToOne)
		}
		
		
		
		return '''
		from dataclasses import dataclass
		«IF e.superType !== null»from «e.superType.name.toString().toLowerCase()» import «e.superType.name»«ENDIF»
		«FOR entry : imports.entrySet()»
		from «entry.getKey()» import «entry.getValue().join(", ")»
        «ENDFOR»
		
		@dataclass
		class «e.name»«IF e.superType !== null»(«e.superType.fullyQualifiedName»)«ENDIF»:
		«e.name.toString().substring(0,0)»    id_«e.name.toLowerCase()»: int
		«FOR rel : relImports.filter[modifier === null || !modifier.allowNull]»
		«e.name.toString().substring(0,0)»    id_«rel.type.name.toString().toLowerCase()»: int
		«ENDFOR»
        «FOR att : attOrdered»
		«att.compile.toString().substring(0,0)»    «att.name»: «pythonType»«IF att.modifier !== null && att.modifier.allowNull» = None«ENDIF»
        «ENDFOR»
        «FOR rel : relImports.filter[modifier !== null && modifier.allowNull]»
		«e.name.toString().substring(0,0)»    id_«rel.type.name.toString().toLowerCase()»: int = None
        «ENDFOR»
    	'''
	}
    
    def dispatch compile(Attribute att) '''
    «att.name»:«att.type.compile.toString()»
    '''
    
	def createSh(){
		return '''
			#!/bin/bash
			psql -U postgres -f ./«this.filename».sql
		'''
	}
	
	
	def start(Resource r) {
		
		tables.clear()
		fks.clear()
		
		for( e : r.allContents.toIterable.filter(Entity)){
			val t = new Table(e.name)
			
			if (e.superType !== null)
				t.extend = e.superType.name
				
			val pk = new Column('id_'+t.name, 'SERIAL')
			pk.primary = true
			pk.allowNull = true
			t.add(pk)
			
			for(att : e.attributes){
				var allowNull = false
				var unique = false
				if (att.modifier !== null){
					if (att.modifier.allowNull) allowNull = true
					if (att.modifier.unique) unique = true
				}
				
				val deflt = if(att.deflt !== null) att.deflt.name
				
				t.add(new Column(att.name, att.type.compile.toString(), allowNull, unique, deflt, false))
					
			}
			
			tables.put(e.name, t)
			
			
			
		}
		
		for( e : r.allContents.toIterable.filter(Entity)){
			for( rel : e.relations){
				val res = rel.compile
				if (res == "OneToOne"){
					val col = new Column('id_'+rel.type.name, 'INTEGER')
					val otoRel = rel as ROneToOne
					if (otoRel.modifier !== null){
						col.allowNull = if(otoRel.modifier.allowNull) true else false
						col.unique = if(otoRel.modifier.unique) true else false
					}
					
					if (fks.containsKey(e.name))
						fks.get(e.name).add(new ForeignKey(e.name, otoRel.type.name, 'id_'+e.name, col.name))
					else{
						val l = new ArrayList()
						l.add(new ForeignKey(e.name, otoRel.type.name, col.name, col.name))
						fks.put(e.name, l)
					}
					
					tables.get(e.name).add(col)
				}
				else if (res == "OneToMany"){
					val col = new Column('id_'+e.name, 'INTEGER')
					val otmRel = rel as ROneToMany
					
					if (otmRel.modifier !== null){
						col.allowNull = if(otmRel.modifier.allowNull) true else false
						col.unique = if(otmRel.modifier.unique) true else false
					}
					
					tables.get(rel.type.name).add(col)
					
					
					if (fks.containsKey(otmRel.type.name))
						fks.get(otmRel.type.name).add(new ForeignKey(otmRel.type.name, e.name, col.name, col.name))
					else{
						val l = new ArrayList()
						l.add(new ForeignKey(otmRel.type.name, e.name, col.name, col.name))
						fks.put(e.name, l)
					}
				}
				else if (res == "ManyToMany"){
					val tab = new Table(e.name + "_" + rel.type.name)
					val mtmRel = rel as RManyToMany
					
					if (!fks.containsKey(tab.name)) fks.put(tab.name, new ArrayList())
						
	
					val pka = new Column('id_'+e.name, 'INTEGER')
					pka.primary = true
					pka.allowNull = true
					fks.get(tab.name).add(new ForeignKey(tab.name, e.name, pka.name, pka.name))
					
					
					val pkb =new Column('id_'+rel.type.name, 'INTEGER')
					pkb.primary = true
					pkb.allowNull = true
					fks.get(tab.name).add(new ForeignKey(tab.name, rel.type.name, pkb.name, pkb.name))
					
					tab.add(pka)
					tab.add(pkb)
					
					for (att : mtmRel.attributes){
						var allowNull = false
						var unique = false
						if (att.modifier !== null){
							if (att.modifier.allowNull) allowNull = true
							if (att.modifier.unique) unique = true
						}
						val deflt = if(att.deflt !== null) att.deflt.name
						tab.add(new Column(att.name, att.type.compile.toString(), allowNull, unique, deflt, false))
					}
					
					for (sm : mtmRel.relations)
						tab.add(new Column('id_'+sm.type.name, 'INTEGER'))
					
					
					tables.put(tab.name, tab)
				}
			}
		}
		
		for (tab : fks.values()){
			var i = 0
			for (fk: tab){
				fk.num = i
				i++
			}
		}
		
		return '''
			drop database if exists «this.filename»;
			create database «this.filename»;
			\connect «this.filename»
			
	        «FOR t : tables.values()»
		        	«t»
	        «ENDFOR»
	        «FOR fklist : fks.values()»
				«FOR fk : fklist»
					«fk»
				«ENDFOR»
				
			«ENDFOR»
		'''
	}
	
	def dispatch compile (ROneToOne v) {
		return "OneToOne"
	}
	
	def dispatch compile (ROneToMany v) {
		return "OneToMany"
	}

	def dispatch compile (RManyToMany v) {
		return "ManyToMany"
	}
	
	def dispatch compile (VarcharImpl v) {
		pythonType="str"
		return "VARCHAR(" + v.n + ")"
	}
	
	def dispatch compile (CharImpl v) {
		pythonType="str"
		return "CHAR(" + v.n + ")"
	}
	
	def dispatch compile (IntegerImpl v) {
		pythonType="int"
		return "INTEGER"
	}

	def dispatch compile (NumericImpl v) {
		pythonType="float"
		var ps = ""
		if(v.p > 0 && v.s > 0)
			ps = "(" + v.p + "," + v.s + ")"
		else if(v.p > 0)
			ps = "(" + v.p + ")"
		
		return "NUMERIC" + ps
	}
	
	def dispatch compile (TextImpl v){
		pythonType="str"
		return "TEXT"
	}
	
	def dispatch compile (BoolImpl v){
		pythonType="bool"
		return "BOOL"
	}

	def dispatch compile (SerialImpl v){
		pythonType="int"
		return "SERIAL"
	}
	
	def dispatch compile (DateImpl v){
		pythonType="date"
		if (!imports.containsKey("datetime")) imports.put("datetime", new HashSet<String>())
		imports.get("datetime").add(pythonType)
		return "DATE"
	}
	
	def dispatch compile (TimeImpl v){
		pythonType="time"
		if (!imports.containsKey("datetime")) imports.put("datetime", new HashSet<String>())
		imports.get("datetime").add(pythonType)
		return "TIME"
	}
	
	def dispatch compile (TimestampImpl v){
		pythonType="datetime"
		if (!imports.containsKey("datetime")) imports.put("datetime", new HashSet<String>())
		imports.get("datetime").add(pythonType)
		return "TIMESTAMP"
	}
	
	def dispatch compile (TimestampzImpl v){
		pythonType="datetime"
		if (!imports.containsKey("datetime")) imports.put("datetime", new HashSet<String>())
		imports.get("datetime").add(pythonType)
		return "TIMESTAMPZ"
	}
	
	def dispatch compile (IntervalImpl v){
		pythonType="timedelta"
		if (!imports.containsKey("datetime")) imports.put("datetime", new HashSet<String>())
		imports.get("datetime").add(pythonType)
		return "INTERVAL"
	}
	
}
